/**
 * Generated by GENERATOR
 * Date: 10/21/2020, 11:36:54 AM
 **/
import { FetchPolicy } from '@/graphql/apolloProvider';
import {
  debounceValidator,
  emailExists,
  oneLower,
  oneUpper,
} from '@/utils/utils.validators';
import { email, maxLength, minLength, required } from '@vuelidate/validators';
import { MutationUpdaterFn } from 'apollo-boost';
import { BaseModel } from '../base/base.model';
import { isEmail } from './../../../utils/utils.validators';
import { GetManyInput } from './../base/interfaces/getManyInput';
import { GetOneInput } from './../base/interfaces/getOneInput';
import {
  CountResponse,
  DistinctResponse,
  ExistsResponse,
  GetManyResponse,
  ListResponse,
  Response,
  UpdateManyResult,
  ValidateResult,
} from './../base/interfaces/returnsInterfaces';
import { CreateUserInput, UpdateUserInput } from './user.inputs';
import { UserService } from './user.service';

const service = new UserService();

export class User extends BaseModel<User>(
  service,
  CreateUserInput,
  UpdateUserInput
) {
  public name: string;
  public identification: string;
  public email: string;
  public accountType: string;
  public address: object;
  public passwordHash?: string;
  public salt?: string;
  public imgProfile?: string;
  public description?: string;
  public meta?: object;
  public active: boolean;

  static async getById(
    id: string,
    fetchPolicy: FetchPolicy = FetchPolicy.cache_first
  ): Promise<Response<User>> {
    return await service.getById(id, fetchPolicy);
  }

  static getOne(
    input: GetOneInput,
    fetchPolicy?: FetchPolicy
  ): Promise<Response<User>> {
    return service.getOne(input, fetchPolicy);
  }

  static getMany(
    getManyInput: GetManyInput,
    fetchPolicy?: FetchPolicy
  ): Promise<GetManyResponse<User>> {
    return service.getMany(getManyInput, fetchPolicy);
  }

  static create(
    input: CreateUserInput,
    scenarios?: string[],
    optimisticResponse?: any,
    update?: MutationUpdaterFn
  ): Promise<Response<User>> {
    return service.create(input, scenarios, optimisticResponse, update);
  }

  static createMany(
    input: CreateUserInput[],
    scenarios?: string[],
    optimisticResponse?: any,
    update?: MutationUpdaterFn
  ): Promise<Response<User[]>> {
    return service.createMany(input, scenarios, optimisticResponse, update);
  }

  static updateById(
    input: any,
    scenarios?: string[],
    optimisticResponse?: any,
    update?: MutationUpdaterFn
  ): Promise<Response<User>> {
    return service.updateById(input, scenarios, optimisticResponse, update);
  }

  static updateMany(
    input: object,
    where: object,
    scenarios?: string[]
  ): Promise<Response<UpdateManyResult>> {
    return service.updateMany(input, where, scenarios);
  }

  static deleteById(
    id: string,
    optimisticResponse?: object,
    update?: MutationUpdaterFn
  ): Promise<Response<User>> {
    return service.deleteById(id, optimisticResponse, update);
  }

  static deleteOne(
    where: object,
    optimisticResponse?: object,
    update?: MutationUpdaterFn
  ): Promise<Response<User>> {
    return service.deleteOne(where, optimisticResponse, update);
  }

  static list(
    where?: object,
    fetchPolicy?: FetchPolicy
  ): Promise<ListResponse> {
    return service.list(where, fetchPolicy);
  }

  static count(
    where: object,
    fetchPolicy?: FetchPolicy
  ): Promise<CountResponse> {
    return service.count(where, fetchPolicy);
  }

  static exists(
    where: object,
    fetchPolicy?: FetchPolicy
  ): Promise<ExistsResponse> {
    return service.exists(where, fetchPolicy);
  }

  static distinct(
    field: string,
    where: object,
    fetchPolicy?: FetchPolicy
  ): Promise<DistinctResponse> {
    return service.distinct(field, where, fetchPolicy);
  }

  static validate(
    input: object,
    scenarios: string[],
    specific?: boolean
  ): Promise<ValidateResult> {
    return service.validate(input, scenarios, specific);
  }

  static validations = (user?) => {
    return {
      user: {
        name: { required, minLength: minLength(2), maxLength: maxLength(40) },
        identification: {
          required,
          maxLength: maxLength(11),
          minLength: minLength(11),
        },
        description: {
          maxLength: maxLength(300),
        },
        email: {
          required,
          email,
          isUnique: debounceValidator(
            emailExists,
            (exists) => !exists,
            (value) => isEmail(value)
          ),
        },
        accountType: { required },
        address: { required },
        password: {
          required,
          minLength: minLength(8),
          passwordOneUpper: oneUpper,
          passwordOneLower: oneLower,
        },
        passwordRepeat: {
          required,
          sameAsPassword: (value) => value == user?.password ?? null,
        },
        license: {},
        imgProfile: {},
        meta: {},
      },
    };
  };

  static feedbacks = {
    user: {
      email: {
        isUnique: 'Ese correo ya est√° registrado. Intente con otro',
      },
    },
  };
}
